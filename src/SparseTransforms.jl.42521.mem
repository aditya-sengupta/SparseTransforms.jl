        - """
        - Sparse transform (SPRIGHT) decoding main file. Logic flow:
        - 
        - 1. Generate a signal from input_signal.jl
        - 2. Subsample from query.jl
        - 3. Peel using reconstruct.jl
        - """
        - module SparseTransforms
        -     export all_methods, spright, method_test, method_report
        -     using ProgressMeter
        -     include("reconstruct.jl")
        -     export fwht, bin_to_dec, dec_to_bin, binary_ints, sign_spright, expected_bin
        -     export Signal, TestSignal, InputSignal, LazySignal, get_subsignal, get_random_sparse_signal, get_random_delta_sparse_signal
        -     export get_D, get_b, get_Ms, subsample_indices, compute_delayed_subtransform
        -     export singleton_detection, bin_cardinality
        -     export decode_with
        - 
        -     all_methods = Dict(
        -         "query" => [:simple, :random],
        -         "delays" => [:identity_like, :random, :nso],
        -         "reconstruct" => [:noiseless, :mle, :nso],
        -         "code" => [:none]
        -     )
        - 
        -     function spright(signal::Signal, methods::Array{Symbol,1}; verbose::Bool=false, report::Bool=false)
        -         return transform(signal, methods, fwht; verbose=verbose, report=report)
        -     end
        - 
        -     """
        -     Full SPRIGHT encoding and decoding. Implements Algorithms 1 and 2 from [2].
        -     (numbers) in the comments indicate equation numbers in [2].
        - 
        -     Arguments
        -     ---------
        -     signal : TestSignal object.
        -     The signal to be transformed / compared to.
        - 
        -     methods : Array{Symbol,1}
        -     The three symbols [query_method, delays_method, reconstruct_method].
        -     All implemented methods are available in `all_methods`: if you add a new method, make sure to update `all_methods`.
        - 
        -         query_method : Symbol
        -         The method to generate the sparsity coefficient and the subsampling matrices.
        -         Currently implemented methods:
        -             :simple : choose some predetermined matrices based on problem size.
        - 
        -         delays_method : Symbol
        -         The method to generate the matrix of delays.
        -         Currently implemented methods:
        -             :identity_like : return a zero row and the identity matrix vertically stacked together.
        -             :random : make a random set of delays.
        -             :nso : set delays according to the NSO-SPRIGHT algorithm.
        - 
        -         reconstruct_method : Symbol
        -         The method to detect singletons.
        -         Currently implemented methods:
        -             :noiseless : decode according to [2], section 4.2, with the assumption the signal is noiseless.
        -             :mle : naive noisy decoding; decode by taking the maximum-likelihood singleton that could be at that bin.
        -             :nso : reconstruct according to the NSO-SPRIGHT algorithm.
        - 
        -     transform : Function
        -     The base transform: either `fwht` or `fft`.
        - 
        -     verbose : Bool
        -     Whether to print intermediate steps.
        - 
        -     report : Bool
        -     Whether to report on algorithm performance.
        - 
        -     Returns
        -     -------
        -     wht : Array{Float64,1}
        -     The WHT constructed by subsampling and peeling.
        -     """
        -     function transform(signal::Signal, methods::Array{Symbol,1}, transform::Function; verbose::Bool=false, report::Bool=false)
     5600         for (method_type, method_name) in zip(["query", "delays", "reconstruct", "code"], methods)
        0             impl_methods = all_methods[method_type]
        0             @assert method_name in impl_methods "$method_type method must be one of $impl_methods"
        -         end
        0         query_method, delays_method, reconstruct_method, code = methods
        0         @assert (reconstruct_method != :so) || (code != :none)
        -         # check the condition for p_failure > eps
        -         # upper bound on the number of peeling rounds, error out after that point
        - 
        -         num_peeling = 0
     4000         locs = []
     4000         strengths = []
    30400         wht = Dict()
        0         b = get_b(signal; method=query_method)
        0         Ms = get_Ms(signal.n, b; method=query_method)
        0         peeling_max = 2^b
        0         N, B = 2^signal.n, 2^b
        - 
     4000         Us = []
        0         if report
    24000             used = Set()
        -         end
        - 
        0         if delays_method == :nso
        0             num_delays = signal.n * Int64(ceil(log2(signal.n))) # idk
        0         elseif delays_method == :so
        0             linearrithmic = signal.n * Int64(ceil(log2(signal.n)))
        0             num_delays = [linearrithmic,    # P1
        -                           signal.n,         # P2
        -                           linearrithmic]    # P3
        -         else
        0             num_delays = signal.n + 1
        -         end
     3344         D = get_D(signal.n; method=delays_method, num_delays=num_delays, code=code)
        0         if reconstruct_method == :mle
        0             K = binary_ints(signal.n)
        0             S = (-1) .^(D * K)
        -         end
        - 
        -         # subsample, make the observation [U] matrices
        0         for M in Ms
     6400             U, used_i = compute_delayed_subtransform(signal, M, D, transform)
     2400             push!(Us, U)
        0             if report
     3200                 used = union(used, used_i)
        -             end
        -         end
        - 
        0         cutoff = 4 * signal.noise_sd ^ 2 * (2 ^ (signal.n - b)) * sum(num_delays) # noise threshold
        - 
        -         # K is the binary representation of all integers from 0 to 2 ** n - 1.
     4000         select_froms = []
        0         for M in Ms
        -             selects = 0
        0             if reconstruct_method == :mle
        0                 selects = @pipe M' * K |> transpose |> Bool.(_) |> eachrow |> bin_to_dec.(_)
        -             end
     2400             push!(select_froms, selects)
        -         end
        -         # `select_froms` is the collection of 'j' values and associated indices
        -         # so that we can quickly choose from the coefficient locations such that M.T * k = j as in (20)
        -         # example: ball j goes to bin at "select_froms[i][j]"" in stage i
        - 
        -         # begin peeling
        -         # index convention for peeling: 'i' goes over all M/U values
        -         # i.e. it refers to the index of the subsampling group (zero-indexed - off by one from the paper).
        -         # 'j' goes over all columns of the WHT subsample matrix, going from 0 to 2 ** b - 1.
        -         # e.g. (i, j) = (0, 2) refers to subsampling group 0, and aliased bin 2 (10 in binary)
        -         # which in the example of section 3.2 is the multiton X[0110] + X[1010] + W1[10]
        - 
        -         # a multiton will just store the (i, j)s in a list
        -         # a singleton will map from the (i, j)s to the true (binary) values k.
        -         # e.g. the singleton (0, 0), which in the example of section 3.2 is X[0100] + W1[00]
        -         # would be stored as the dictionary entry (0, 0): array([0, 1, 0, 0]).
        - 
        -         multitons_found = true
        -         iters = 0
        0         max_iters = 2 ^ (b + 1)
        0         while multitons_found && (num_peeling < peeling_max) && (iters < max_iters)
        - 
        -             # first step: find all the singletons and multitons.
    46816             singletons = Dict() # dictionary from (i, j) values to the true index of the singleton, k.
     6160             multitons = [] # list of (i, j) values indicating where multitons are.
        - 
        0             for (i, (M, U, select_from)) in enumerate(zip(Ms, Us, select_froms))
     9856                 col_gen = U |> eachrow |> enumerate
   354816                 for (j, col) in col_gen
    78848                     if col⋅col > cutoff
     6064                         selection = findall(==(j-1), select_from) # pick all the k such that M.T @ k = j
        -                         slice = 0
        0                         if reconstruct_method == :mle
        0                             slice = S[:, selection]
        -                         end
    54736                         k, ρ, s_k = singleton_detection(
        -                             col;
        -                             method=reconstruct_method,
        -                             selection=selection,
        -                             S_slice=slice,
        -                             n=signal.n,
        -                             num_delays=num_delays,
        -                             D=D
        -                         ) # find the best fit singleton
        0                         residual = col - ρ * s_k
    12128                         if (expected_bin(k, M) != j) || (residual ⋅ residual > cutoff)
     4368                             push!(multitons, [i, j])
        -                         else # declare as singleton
    22336                             singletons[(i, j)] = (k, ρ)
        -                         end # if residual norm > cutoff
        -                     end # if col norm > cutoff
        -                 end # for col
        -             end # for U, select_from
        - 
        -             # all singletons and multitons are discovered
        0             if verbose
    13104                 println("Singletons:")
        0                 for (ston_key, ston_value) in singletons
        0                     println(ston_key, bin_to_dec(ston_value[1]))
        -                 end
        - 
    27664                 println("Multitons : $multitons")
        -             end
        - 
        -             # WARNING: this is not a correct thing to do
        -             # in the last iteration of peeling, everything will be singletons and there
        -             # will be no multitons
        0             if length(multitons) == 0 # no more multitons, and can construct final transform
        -                 multitons_found = false
        -             end
        - 
        -             # balls to peel
    36960             balls_to_peel = Set()
    46816             ball_values = Dict()
     5552             for (_, (k, ρ)) in singletons
        0                 ball = bin_to_dec(k)
     5552                 push!(balls_to_peel, ball)
        0                 ball_values[ball] = ρ
        -             end
        - 
        0             if verbose
    12768                 println("Balls to be peeled")
        0                 println(balls_to_peel)
        -             end
        -             # peel
        0             iters += 1
        0             for ball in balls_to_peel
        0                 num_peeling += 1
        0                 k = dec_to_bin(ball, signal.n)
        - 
     2800                 push!(locs, k)
     2800                 push!(strengths, ball_values[ball])
        - 
        0                 for (l, M) in enumerate(Ms)
   131200                     peel = @pipe M' * k |> _ .% 2 |> Bool.(_) |> bin_to_dec |> _ + 1
        0                     signature_in_stage = (-1) .^ (D * k)
        0                     to_subtract = ball_values[ball] * signature_in_stage
        0                     U = Us[l]
     6560                     U_slice = U[peel, :]
     6560                     Us[l][peel,:] = U_slice - to_subtract
        0                     if verbose
   274496                         println("Peeled ball $(bin_to_dec(k)) off bin ($l, $peel)")
        -                     end
        -                 end # for peel
        -             end # for ball
        -         end # while
        - 
    24000         loc = Set()
        0         for (k, value) in zip(locs, strengths) # iterating over (i, j)s
        0             idx = bin_to_dec(k) # converting 'k's of singletons to decimals
     3280             push!(loc, idx)
        0             if !haskey(wht, idx)
        0                 wht[idx] = value
        -             end
        -         end
        - 
        0         wht = Dict(i => x / (2 ^ b) for (i,x) in wht)
     3200         wht = filter(f -> abs(last(f)) ≥ signal.noise_sd, wht)
        0         if report
     1600             return wht, length(used)
        -         else
        0             return wht
        -         end
        -     end
        - end # module
